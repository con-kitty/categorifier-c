{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE HexFloatLiterals #-}
{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE RankNTypes #-}
{-# OPTIONS_GHC -Wno-redundant-constraints #-}

-- | Utilities for dealing with the boundaries of safe rounding operations.
--
-- This module exists because we need to get rounding behavior in multiple backends to line up
-- exactly.  The root of the rounding algorithm is from the SBV library.
--
-- == Backstory
--
-- If you would like to know (a lot) more about how this mess came about, please visit
-- <https://github.com/LeventErkok/sbv/issues/456 this issue page>.
--
-- == Constants
--
-- The constant boundaries in this module were generated by a C program.  You can see the raw output
-- by running
--
-- > kazel run \/\/code_generation\/hk_classes\/constants:float_constants
--
-- TODO(peddie): make this a genrule!
module Kitty.KTypes.Round
  ( Interval (..),
    RoundBounds (..),
    Roundable,
    getRoundBounds,
    safeRound,
    KRound (..),
  )
where

import Data.HashMap.Strict (HashMap)
import qualified Data.HashMap.Strict as HashMap
import Data.Hashable (Hashable)
import Data.Int (Int64)
import Data.Maybe (fromMaybe)
import Data.Proxy (Proxy (..))
import qualified Data.Type.Nat as Nat
import GHC.Generics (Generic)
import Kitty.KTypes.BooleanLogic (KAnd (..))
import Kitty.KTypes.Conditional (KTernary (..))
import Kitty.KTypes.IEEE (KIsInfinite (..), KIsNaN (..))
import Kitty.KTypes.KLiteral (KLiteral (..))
import Kitty.KTypes.TotalOrder (KOrd (..))
import Kitty.Prim (IsPrimitive (..), PrimFractional, PrimIntegral, signedIntPrimTypes, unTagged)

data Signedness = Signed | Unsigned deriving (Show, Eq, Generic)

instance Hashable Signedness

floatRoundBoundsMap :: HashMap (Signedness, Int) (Interval b Float)
floatRoundBoundsMap =
  HashMap.fromListWith
    const
    [ ((Unsigned, 8), Interval (-0x1p-1) 0x1.fefffep+7),
      ((Unsigned, 16), Interval (-0x1p-1) 0x1.fffefep+15),
      ((Unsigned, 32), Interval (-0x1p-1) 0x1.fffffep+31),
      ((Unsigned, 64), Interval (-0x1p-1) 0x1.fffffep+63),
      ((Signed, 8), Interval (-0x1.01p+7) 0x1.fdfffep+6),
      ((Signed, 16), Interval (-0x1.0001p+15) 0x1.fffdfep+14),
      ((Signed, 32), Interval (-0x1p+31) 0x1.fffffep+30),
      ((Signed, 64), Interval (-0x1p+63) 0x1.fffffep+62)
    ]

doubleRoundBoundsMap :: HashMap (Signedness, Int) (Interval b Double)
doubleRoundBoundsMap =
  HashMap.fromListWith
    const
    [ ((Unsigned, 8), Interval (-0x1p-1) 0x1.fefffffffffffp+7),
      ((Unsigned, 16), Interval (-0x1p-1) 0x1.fffefffffffffp+15),
      ((Unsigned, 32), Interval (-0x1p-1) 0x1.fffffffefffffp+31),
      ((Unsigned, 64), Interval (-0x1p-1) 0x1.fffffffffffffp+63),
      ((Signed, 8), Interval (-0x1.01p+7) 0x1.fdfffffffffffp+6),
      ((Signed, 16), Interval (-0x1.0001p+15) 0x1.fffdfffffffffp+14),
      ((Signed, 32), Interval (-0x1.00000001p+31) 0x1.fffffffdfffffp+30),
      ((Signed, 64), Interval (-0x1p+63) 0x1.fffffffffffffp+62)
    ]

class Roundable a where
  roundBoundsMap :: HashMap (Signedness, Int) (Interval b a)

instance Roundable Float where
  roundBoundsMap = floatRoundBoundsMap

instance Roundable Double where
  roundBoundsMap = doubleRoundBoundsMap

data Interval b a = Interval
  { intervalLower :: a,
    intervalUpper :: a
  }
  deriving (Eq, Show, Ord, Functor, Foldable, Traversable)

data RoundBounds b a = RoundBounds
  { roundBoundsIntRange :: Interval b a,
    roundBoundsFallbackInt64Cast :: Interval b a
  }
  deriving (Eq, Show, Ord, Functor, Foldable, Traversable)

getRoundBounds ::
  forall a b.
  ( Roundable a,
    IsPrimitive b
  ) =>
  RoundBounds b a
getRoundBounds = RoundBounds intRange fallbackInt64Cast
  where
    signedness =
      if unTagged (primType @b) `elem` signedIntPrimTypes
        then Signed
        else Unsigned
    size = 8 * Nat.reflectToNum (Proxy @(PrimSizeBytes b))
    fallbackInt64Cast = lookupBounds (Signed, 64)
    intRange = lookupBounds (signedness, size)
    lookupBounds idx = fromMaybe (idxErr idx) $ HashMap.lookup idx roundBoundsMap
    idxErr idx = error $ "Invalid rounding index '" <> show idx <> "'!"

-- | Below is the rounding algorithm for going from floating-point to integral.  The "range" of an
-- integer type is defined as the closed interval bounded by the minimum and maximum value for which
-- floating-point rounding is defined behavior in C according to C99 and IEEE754-2008, for
-- round-to-nearest ties-to-even-mantissa rounding mode.
--
-- For example, @-1e-9@ is "in range" of 'Data.Word.Word8', because rounding a 'Float' or 'Double'
-- with this value to 'Data.Word.Word8' is entirely defined (resulting in 0).
--
-- For another example, @'maxBound' :: 'Data.Word.Word32'@ is @4294967295@.  The nearest
-- floating-point value to this is @4294967296.0@.  This floating-point value is _not_ "in range" of
-- 'Data.Word.Word32', since no matter how you want to handle tiebreaking and rounding, it's a whole
-- integer above the largest possible 'Data.Word.Word32'.  In other words, converting an integer
-- value to floating-point and then converting back to the original integer type is not guaranteed
-- to be defined behavior, let alone the identity function.  If you don't like this, please tell me
-- how you would rather solve this problem.
--
-- Here is the algorithm:
--
--      1. If the floating-point value is any @NaN@, return 0.
--
--      2. If the floating-point value is @Infinity@ or @-Infinity@, return 0.
--
--      3. If the floating-point value is within the range of the output type, round directly.
--
--      4. If the floating-point value is outside the range of the output type but within the range
--         of 'Int64', first round to 'Int64', then round to the output type.
--
--      5. If the floating-point value is outside the range of both the output type and 'Int64',
--      round it to the appropriate bound of the output type.
--
-- Why do we go via 'Int64' if we can?  Recall that Haskell always goes via 'Integer' when doing
-- this kind of rounding.  This means that all cases are defined; any integer can be represented by
-- 'Integer', and integer rounding is fully defined in Haskell when going from 'Integer' to any @a@
-- with an instance of 'Num' (see 'fromInteger').  Sadly, in the flight controller, we cannot use
-- arbitrary-precision 'Integer's due to strict time and memory behavior constraints.  But if we go
-- from a floating-point value outside the range of 'Data.Word.Word8', we can approximate Haskell's
-- behavior if the floating-point value is in range of 'Int64'.
--
-- Given that we're trying to approximate Haskell's behavior, why do we round to the bounds of the
-- output type if the value would require arbitrary-precision integers to correctly round?  The
-- answer is that it seems better than emitting zero.  Arguably we should do the same in the case of
-- @Infinity@ and @-Infinity@, but we have been flying with SBV's behavior of emitting 0 in these
-- cases, so where it's not necessary to change the semantics in order to avoid undefined behavior,
-- I've elected to leave things alone.
--
-- === Temporary infelicities
--
-- Currently there is an odd corner case: when we're casting a value that's greater than the upper
-- bound of both 'Data.Word.Word64' and 'Int64', we will go via 'Int64' (as we fail the initial
-- bounds check) and never look back, clamping to @INT64_MAX@, when it could be argued we should
-- clamp to @UINT64_MAX@ in this case.  TODO(MP)!
safeRound ::
  forall a b f.
  ( KAnd f,
    KIsInfinite f a,
    KIsNaN f a,
    KOrd f (f a),
    KLiteral f b,
    KLiteral f a,
    KTernary f (f b),
    PrimFractional a,
    PrimIntegral b,
    Bounded b,
    Roundable a
  ) =>
  (f a -> f b) ->
  (f a -> f Int64) ->
  (f Int64 -> f b) ->
  f a ->
  f b
safeRound unsafeLowLevelCast unsafeInt64Cast integralCast fpValue =
  -- Check for @NaN@ (step 1)
  kTernary (kIsNaN fpValue) (kliteral 0)
    -- Check for @Infinity@ (step 2)
    . kTernary (kIsInfinite fpValue) (kliteral 0)
    -- Convert directly if within output type bounds (step 3)
    . kTernary withinOutputBounds directCast
    -- Convert via 'Int64' if within 'Int64' bounds
    . kTernary withinSafeBounds fallbackInt64Cast
    -- At this point, we must be outside the 'Int64' bounds and the output bounds, so we are
    -- either below the minimum value ('fallbackInt64LowerBound' is used here, because it is
    -- never greater than 'outputLowerBound') or above the maximum value.
    $ kTernary
      (fpValue .<= fallbackInt64LowerBound)
      (kliteral minBound)
      (kliteral maxBound)
  where
    withinOutputBounds = fpValue .>= outputLowerBound .&& fpValue .<= outputUpperBound
    withinSafeBounds = fpValue .>= fallbackInt64LowerBound .&& fpValue .<= fallbackInt64UpperBound
    directCast = unsafeLowLevelCast fpValue
    fallbackInt64Cast = integralCast $ unsafeInt64Cast fpValue
    _bounds :: RoundBounds b (f a)
    _bounds@(RoundBounds outputBounds fallbackInt64Bounds) = kliteral <$> getRoundBounds
    Interval outputLowerBound outputUpperBound = outputBounds
    Interval fallbackInt64LowerBound fallbackInt64UpperBound = fallbackInt64Bounds

class
  ( Integral a,
    Bounded a,
    KLiteral f a,
    KTernary f (f a)
  ) =>
  KRound f a
  where
  -- | The equivalent of glibc 'round'.
  -- Beware; this function will wrap for out-or-range numbers,
  -- including rounding negative floats to unsigned ints.
  -- They also round @Infinity@ and @NaN@ to 0.
  kRoundDouble :: f Double -> f a

  -- | Same behavior as 'kRoundDouble' but for 'Float's.
  kRoundFloat :: f Float -> f a

-- Floor/ceil/etc would naturally go where but are intentionally left out to reduce API. They can be
-- commented in if needed.
-- kFloor :: (Real a, Fractional a, Integral b) => f a -> f b
-- kCeil :: (Real a, Fractional a, Integral b) => f a -> f b
